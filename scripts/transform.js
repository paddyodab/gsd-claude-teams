#!/usr/bin/env node

/**
 * GSD Teams Transform Script
 *
 * Copies original/get-shit-done/get-shit-done/ → adapted/ with per-developer state isolation.
 * Re-run after pulling upstream GSD updates (git submodule update).
 *
 * Touch points:
 *   1. bin/lib/teams.cjs — NEW helper module written by this script
 *   2. bin/lib/*.cjs — inject require('./teams.cjs') and patch statePath assignments
 *   3. bin/gsd-tools.cjs — inject CLI subcommands (state-path, etc.)
 *   4. Markdown files — route raw cat/@ STATE.md references through gsd-tools.cjs
 *
 * Touch point 5 (absolute paths) is handled at runtime by /team:handoff, not here.
 */

const fs = require('fs');
const path = require('path');

// Upstream restructured: runtime files are nested under get-shit-done/get-shit-done/
const SOURCE = path.resolve(__dirname, '..', 'original', 'get-shit-done', 'get-shit-done');
const DEST = path.resolve(__dirname, '..', 'adapted');

// Documentation files — don't transform references in these
const SKIP_TRANSFORM = new Set(['CHANGELOG.md', 'README.md', 'USER-GUIDE.md', 'LICENSE']);

// ─── teams.cjs helper module ────────────────────────────────────────────────

// Written to adapted/bin/lib/teams.cjs — imported by each patched lib module
const TEAMS_CJS_CONTENT = `/**
 * GSD Teams — per-developer state isolation helpers
 * Generated by gsd-claude-teams/scripts/transform.js
 */

const fs = require('fs');
const path = require('path');

function getDeveloper() {
  // CLI flag: --developer <name>
  const flagIdx = process.argv.indexOf('--developer');
  if (flagIdx !== -1 && process.argv[flagIdx + 1]) {
    return process.argv[flagIdx + 1];
  }
  // Environment variable
  if (process.env.GSD_DEVELOPER) {
    return process.env.GSD_DEVELOPER;
  }
  // config.json developer field
  try {
    const cfgRaw = fs.readFileSync(path.join(process.cwd(), '.planning', 'config.json'), 'utf-8');
    const cfg = JSON.parse(cfgRaw);
    if (cfg.developer) return cfg.developer;
  } catch {}
  return null;
}

function resolveStatePath(baseDir) {
  const dev = getDeveloper();
  const stateFile = dev ? \`STATE_\${dev}.md\` : 'STATE.md';
  return path.join(baseDir, stateFile);
}

function resolveAgentHistoryPath(baseDir) {
  const dev = getDeveloper();
  const file = dev ? \`agent-history_\${dev}.json\` : 'agent-history.json';
  return path.join(baseDir, file);
}

function resolveCurrentAgentIdPath(baseDir) {
  const dev = getDeveloper();
  const file = dev ? \`current-agent-id_\${dev}.txt\` : 'current-agent-id.txt';
  return path.join(baseDir, file);
}

module.exports = { getDeveloper, resolveStatePath, resolveAgentHistoryPath, resolveCurrentAgentIdPath };
`;

// ─── CLI subcommands for gsd-tools.cjs ──────────────────────────────────────

const STATE_PATH_CMD = `
  // ─── GSD Teams: expose resolved paths to shell ──────────────────────────────
  if (command === 'state-path') {
    const { resolveStatePath } = require('./lib/teams.cjs');
    process.stdout.write(resolveStatePath(path.join(cwd, '.planning')));
    process.exit(0);
  }
  if (command === 'agent-history-path') {
    const { resolveAgentHistoryPath } = require('./lib/teams.cjs');
    process.stdout.write(resolveAgentHistoryPath(path.join(cwd, '.planning')));
    process.exit(0);
  }
  if (command === 'current-agent-id-path') {
    const { resolveCurrentAgentIdPath } = require('./lib/teams.cjs');
    process.stdout.write(resolveCurrentAgentIdPath(path.join(cwd, '.planning')));
    process.exit(0);
  }
`;

// ─── Lib module patches ─────────────────────────────────────────────────────

// Files that need the teams.cjs require injected and statePath patched
const LIB_PATCH_TARGETS = new Set(['state.cjs', 'phase.cjs', 'milestone.cjs', 'verify.cjs', 'init.cjs']);

// The require line to inject after existing requires in each lib module
const TEAMS_REQUIRE = "const { resolveStatePath, resolveCurrentAgentIdPath } = require('./teams.cjs');";

function patchLibModule(content, fileName) {
  let patched = content;
  let statePathReplacements = 0;
  let agentIdReplacements = 0;

  // 1. Inject teams.cjs require after existing requires
  //    Find the last require() line at the top of the file (before function defs)
  const lines = patched.split('\n');
  let lastRequireIdx = -1;
  for (let i = 0; i < lines.length; i++) {
    if (lines[i].match(/^const\s+.*=\s+require\(/)) {
      lastRequireIdx = i;
    }
    // Stop at first function definition or substantial code
    if (lines[i].match(/^function\s/) || lines[i].match(/^(async\s+)?function\s/)) break;
  }

  if (lastRequireIdx === -1) {
    throw new Error(`Could not find require block in ${fileName}`);
  }

  lines.splice(lastRequireIdx + 1, 0, TEAMS_REQUIRE);
  patched = lines.join('\n');

  // 2. Replace all `const statePath = path.join(cwd, '.planning', 'STATE.md');`
  patched = patched.replace(
    /const statePath = path\.join\(cwd, '\.planning', 'STATE\.md'\);/g,
    () => { statePathReplacements++; return "const statePath = resolveStatePath(path.join(cwd, '.planning'));"; }
  );

  // 3. Replace `const statePath = path.join(planningDir, 'STATE.md');`
  patched = patched.replace(
    /const statePath = path\.join\(planningDir, 'STATE\.md'\);/g,
    () => { statePathReplacements++; return "const statePath = resolveStatePath(planningDir);"; }
  );

  // 4. Replace inline `fs.readFileSync(path.join(planningDir, 'STATE.md'), 'utf-8')`
  //    (state.cjs cmdStateLoad has this pattern)
  patched = patched.replace(
    /fs\.readFileSync\(path\.join\(planningDir, 'STATE\.md'\), 'utf-8'\)/g,
    () => { statePathReplacements++; return "fs.readFileSync(resolveStatePath(planningDir), 'utf-8')"; }
  );

  // 5. Replace inline `fs.readFileSync(path.join(cwd, '.planning', 'STATE.md'), 'utf-8')`
  //    (init.cjs cmdInitResume has this pattern)
  patched = patched.replace(
    /fs\.readFileSync\(path\.join\(cwd, '\.planning', 'STATE\.md'\), 'utf-8'\)/g,
    () => { statePathReplacements++; return "fs.readFileSync(resolveStatePath(path.join(cwd, '.planning')), 'utf-8')"; }
  );

  // 6. Replace current-agent-id.txt reference
  //    (init.cjs has: path.join(cwd, '.planning', 'current-agent-id.txt'))
  patched = patched.replace(
    /path\.join\(cwd, '\.planning', 'current-agent-id\.txt'\)/g,
    () => { agentIdReplacements++; return "resolveCurrentAgentIdPath(path.join(cwd, '.planning'))"; }
  );

  return { patched, statePathReplacements, agentIdReplacements };
}

// ─── gsd-tools.cjs main file patch ──────────────────────────────────────────

function patchGsdTools(content) {
  let patched = content;
  let stats = { injectedCommands: false };

  // Inject state-path/agent-history-path/current-agent-id-path CLI commands
  // before the switch(command) dispatch
  const dispatchMarker = "switch (command) {";
  const dispatchIdx = patched.indexOf(dispatchMarker);
  if (dispatchIdx === -1) {
    throw new Error('Could not find switch(command) dispatch in gsd-tools.cjs');
  }
  patched = patched.slice(0, dispatchIdx) + STATE_PATH_CMD + '\n  ' + patched.slice(dispatchIdx);
  stats.injectedCommands = true;

  return { patched, stats };
}

// ─── Markdown patches ────────────────────────────────────────────────────────

// Full path to gsd-tools.cjs as used in GSD's own markdown files
const GSD_TOOLS = '~/.claude/get-shit-done/bin/gsd-tools.cjs';

function patchMarkdown(content, filePath) {
  let patched = content;
  const relPath = path.relative(SOURCE, filePath);
  let changes = 0;

  // Replace shell cat/read commands for STATE.md with gsd-tools.cjs resolution
  patched = patched.replace(
    /cat\s+\.planning\/STATE\.md(\s+2>\/dev\/null)?/g,
    (match, devnull) => { changes++; return `cat "$(node ${GSD_TOOLS} state-path)"${devnull || ''}`; }
  );

  // Replace --files .planning/STATE.md in commit commands
  patched = patched.replace(
    /(--files\s+(?:[^\n]*?))(\.planning\/STATE\.md)/g,
    (match, prefix, stateRef) => { changes++; return `${prefix}"$(node ${GSD_TOOLS} state-path)"`; }
  );

  // Replace agent-history.json references in bash contexts
  patched = patched.replace(
    /\.planning\/agent-history\.json/g,
    () => { changes++; return `"$(node ${GSD_TOOLS} agent-history-path)"`; }
  );

  // Replace current-agent-id.txt references in bash contexts
  patched = patched.replace(
    /\.planning\/current-agent-id\.txt/g,
    () => { changes++; return `"$(node ${GSD_TOOLS} current-agent-id-path)"`; }
  );

  return { patched, changes, relPath };
}

// ─── File walking & copying ──────────────────────────────────────────────────

function walkDir(dir) {
  const entries = [];
  for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
    const fullPath = path.join(dir, entry.name);
    if (entry.name === '.git' || entry.name === 'node_modules') continue;
    if (entry.isDirectory()) {
      entries.push(...walkDir(fullPath));
    } else {
      entries.push(fullPath);
    }
  }
  return entries;
}

function transform() {
  console.log('GSD Teams Transform');
  console.log('===================');
  console.log(`Source: ${SOURCE}`);
  console.log(`Dest:   ${DEST}`);
  console.log('');

  if (!fs.existsSync(SOURCE)) {
    console.error('ERROR: Source directory not found.');
    console.error('Expected nested structure: original/get-shit-done/get-shit-done/');
    console.error('Run: git submodule update --init');
    process.exit(1);
  }

  // Clean destination
  if (fs.existsSync(DEST)) {
    fs.rmSync(DEST, { recursive: true });
  }

  // Write teams.cjs helper module first
  const teamsCjsDest = path.join(DEST, 'bin', 'lib', 'teams.cjs');
  fs.mkdirSync(path.dirname(teamsCjsDest), { recursive: true });
  fs.writeFileSync(teamsCjsDest, TEAMS_CJS_CONTENT, 'utf-8');
  console.log('  CREATED  bin/lib/teams.cjs (helper module)');

  const files = walkDir(SOURCE);
  let mdPatched = 0;
  let mdSkipped = 0;
  let copied = 0;
  let totalStatePathReplacements = 0;
  let totalAgentIdReplacements = 0;
  let toolsStats = null;
  let libPatchResults = [];

  for (const srcPath of files) {
    const relPath = path.relative(SOURCE, srcPath);
    const destPath = path.join(DEST, relPath);
    const destDir = path.dirname(destPath);
    const fileName = path.basename(srcPath);

    // Ensure destination directory exists
    fs.mkdirSync(destDir, { recursive: true });

    // gsd-tools.cjs gets CLI subcommand injection
    if (relPath === path.join('bin', 'gsd-tools.cjs')) {
      const content = fs.readFileSync(srcPath, 'utf-8');
      const { patched, stats } = patchGsdTools(content);
      fs.writeFileSync(destPath, patched, 'utf-8');
      toolsStats = stats;
      console.log(`  PATCHED  ${relPath}`);
      console.log(`           → injected state-path/agent-history-path/current-agent-id-path commands`);
      continue;
    }

    // Lib modules that reference STATE.md get patched
    if (relPath.startsWith(path.join('bin', 'lib')) && LIB_PATCH_TARGETS.has(fileName)) {
      const content = fs.readFileSync(srcPath, 'utf-8');
      const result = patchLibModule(content, fileName);
      fs.writeFileSync(destPath, result.patched, 'utf-8');
      totalStatePathReplacements += result.statePathReplacements;
      totalAgentIdReplacements += result.agentIdReplacements;
      libPatchResults.push({ file: fileName, ...result });
      console.log(`  PATCHED  ${relPath} (${result.statePathReplacements} state, ${result.agentIdReplacements} agent-id)`);
      continue;
    }

    // Markdown files get path transforms (unless they're documentation)
    if (fileName.endsWith('.md') && !SKIP_TRANSFORM.has(fileName)) {
      const content = fs.readFileSync(srcPath, 'utf-8');
      const { patched, changes } = patchMarkdown(content, srcPath);
      fs.writeFileSync(destPath, patched, 'utf-8');
      if (changes > 0) {
        mdPatched++;
        console.log(`  PATCHED  ${relPath} (${changes} changes)`);
      } else {
        mdSkipped++;
      }
      continue;
    }

    // Everything else: straight copy
    fs.copyFileSync(srcPath, destPath);
    copied++;
  }

  // Validation
  console.log('');
  console.log('Summary');
  console.log('-------');
  console.log(`Total files:      ${files.length}`);
  console.log(`Straight copies:  ${copied}`);
  console.log(`MD patched:       ${mdPatched}`);
  console.log(`MD unchanged:     ${mdSkipped}`);
  console.log(`teams.cjs:        created (helper module)`);

  // Per-file breakdown
  console.log('');
  console.log('Lib module patches:');
  for (const r of libPatchResults) {
    console.log(`  ${r.file}: ${r.statePathReplacements} statePath + ${r.agentIdReplacements} agentId`);
  }
  console.log(`  Total: ${totalStatePathReplacements} statePath + ${totalAgentIdReplacements} agentId`);

  if (toolsStats) {
    console.log(`\ngsd-tools.cjs:    ✓ CLI subcommands injected`);
  } else {
    console.error('\nWARNING: bin/gsd-tools.cjs not found in source!');
  }

  // Validate expected counts
  const expectedStatePath = 18;
  const expectedAgentId = 1;

  if (totalStatePathReplacements !== expectedStatePath) {
    console.error(`\nWARNING: Expected ${expectedStatePath} statePath replacements, got ${totalStatePathReplacements}`);
    console.error('The upstream lib modules may have changed. Review manually.');
  } else {
    console.log(`\nValidation:       ✓ ${totalStatePathReplacements}/${expectedStatePath} statePath replacements`);
  }

  if (totalAgentIdReplacements !== expectedAgentId) {
    console.error(`WARNING: Expected ${expectedAgentId} agentId replacement, got ${totalAgentIdReplacements}`);
  } else {
    console.log(`                  ✓ ${totalAgentIdReplacements}/${expectedAgentId} agentId replacements`);
  }

  console.log('\nDone. Adapted files are in adapted/');
}

transform();
